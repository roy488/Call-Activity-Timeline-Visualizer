<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Call Activity Timeline</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- SheetJS for XLSX parsing -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #f7f9fb; }
        .timeline-container { overflow-x: scroll; width: 100%; }
        .timeline-chart { position: relative; min-width: 1500px; /* Base width for initial load */ }
        .agent-track { height: 35px; border-bottom: 1px solid #e5e7eb; position: relative; }
        .call-bar { position: absolute; height: 25px; top: 5px; border-radius: 4px; transition: transform 0.1s; cursor: pointer; }
        .downtime-bar { position: absolute; height: 3px; top: 16px; background-color: #ef4444; /* Red-500 */ border-radius: 1px; }
        .call-bar:hover { z-index: 10; transform: scaleY(1.2); }
        .tooltip {
            position: absolute;
            z-index: 20;
            background-color: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            transform: translate(-50%, -10px);
            min-width: 200px;
        }
        .show-tooltip { opacity: 1; transform: translate(-50%, -40px); }
        #agent-list-panel { max-height: 150px; overflow-y: auto; padding: 8px; border: 1px solid #e2e8f0; border-radius: 6px; background-color: #f8fafc; width: 200px; }
        .agent-checkbox-item { display: flex; align-items: center; padding: 2px 0; font-size: 0.9rem; cursor: pointer; }
        .agent-checkbox-item:hover { background-color: #eff6ff; border-radius: 4px; }
        /* Ensures agent labels and tracks align perfectly */
        .agent-label-row { height: 35px; line-height: 35px; border-bottom: 1px solid #e5e7eb; }
        #agent-labels-header { height: 36px; } /* Adjust header height to align with first track */
    </style>
</head>
<body class="p-8">

<div id="app" class="max-w-7xl mx-auto">
    <header class="mb-8 p-4 bg-white rounded-xl shadow-lg border-b-4 border-emerald-500">
        <h1 class="text-3xl font-bold text-gray-800">Agent Call Activity Timeline</h1>
        <p id="date-range-summary" class="text-gray-500 mt-1">
            Load a RingCentral XLSX Calls file to begin analysis.
        </p>
    </header>

    <div class="flex justify-between items-start mb-6 p-4 bg-white rounded-xl shadow">
        <div class="flex items-center space-x-4">
            <div class="flex flex-col">
                <label class="text-sm font-medium text-gray-700">Zoom Level:</label>
                <input type="range" id="zoom-slider" min="100" max="400" value="100"
                       class="w-48 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer range-sm">
            </div>
        </div>

        <div class="flex flex-col items-end">
            <div class="flex items-center mb-1">
                <label class="text-sm font-medium text-gray-700 mr-2">Filter Agents:</label>
                <span id="filter-feedback"
                      class="text-xs font-semibold px-2 py-1 rounded-full bg-emerald-100 text-emerald-700">0 Agents Selected</span>
            </div>
            <div id="agent-list-panel">
                <p class="text-gray-500 text-center text-sm">Upload data to load agents.</p>
            </div>
            <div class="flex space-x-2 mt-2">
                <button id="applyFilter"
                        class="px-3 py-2 bg-emerald-500 text-white rounded-md hover:bg-emerald-600 transition font-medium text-sm">
                    Apply Filter
                </button>
                <button id="clearSelection"
                        class="px-3 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition font-medium text-sm">
                    Clear Selection
                </button>
            </div>
        </div>
    </div>

    <div id="drop-area"
         class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center bg-white hover:border-emerald-400 transition cursor-pointer mb-8">
        <input type="file" id="fileInput" accept=".xlsx,.xls" class="hidden">
        <p class="text-lg font-medium text-gray-700">**DROP RINGCENTRAL XLSX CALLS FILE HERE**</p>
        <p class="text-sm text-gray-500 mt-1">
            Expects the <strong>Multi-Day Agent Stats – Calls</strong> XLSX export (uses the “Calls” sheet).
        </p>
    </div>

    <div id="visualization-area" class="flex bg-white rounded-xl shadow-lg overflow-hidden border">
        <div id="agent-names-column" class="flex-shrink-0 w-48 border-r bg-gray-50">
            <div id="agent-labels-header"
                 class="px-3 text-xs font-semibold text-gray-600 uppercase border-b border-gray-300 flex items-center">
                Agent Name
            </div>
            <div id="agent-label-container"></div>
        </div>

        <div id="timeline-scroll-container" class="timeline-container relative">
            <div id="timeline-chart" class="timeline-chart"></div>
        </div>
    </div>

    <div id="call-tooltip" class="tooltip"></div>

    <div id="stats-summary-area"
         class="mt-8 p-6 bg-white rounded-xl shadow-lg border-t-4 border-emerald-500"
         style="display: none;">
        <h2 class="text-2xl font-semibold text-gray-700 mb-4">Daily Productivity Metrics (8-Hour Net)</h2>
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                <tr>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Agent Name</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Calls</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Inbound Handle Time</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Outbound Handle Time</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total Productive Time</th>
                    <th class="px-6 py-3 text-left text-xs font-medium text-red-600 uppercase tracking-wider">Time Off Phone (8h)</th>
                </tr>
                </thead>
                <tbody id="stats-table-body" class="bg-white divide-y divide-gray-200"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    // --- Constants ---
    const VALID_RESULTS_CONNECTED = ["Connected", "Answered"];
    const VALID_RESULTS_TRANSFERRED = ["Transferred", "Transferred / To Voicemail"];

    // --- UPDATED AGENT LIST ---
    const AGENT_LIST = [
        "ALEJANDRO SATUNINO CAMPOS-PEREZ",
        "AUSTIN MITCHELL",
        "Brady Olson",
        "Brandon Ridder",
        "BRANDON RUSSOM",
        "BRENDAN BOH",
        "Cullen Manley",
        "David Ryan",
        "DOMINIQUE GONZALES",
        "Duncan Cannon",
        "Hayden Holcomb",
        "Joel Jubber",
        "John Udick",
        "KIMBERLY RAMIREZ",
        "MARCOS HERNANDEZ",
        "MOUNIR ROSENDO",
        "Natasha Fowler",
        "Nathan Hill",
        "Olivia Kasten",
        "Tammy Lummus",
        "Wanda Scott"
    ];
    const AGENT_MAP = new Map(AGENT_LIST.map(name => [name.toUpperCase(), name]));
    const DIRECT_ALIAS_MAP = { "NATE": "Nathan Hill" };

    // --- Standardized Workday (8:30 AM to 5:30 PM) ---
    const START_OF_DAY_SECONDS = 8.5 * 3600; // 8:30 AM
    const END_OF_DAY_SECONDS = 17.5 * 3600;  // 5:30 PM
    const NET_WORKDAY_SECONDS = 8 * 3600;    // 8 hours net productive time

    // --- Custom Highlight Threshold (4 hours) ---
    const IDLE_TIME_HIGHLIGHT_SECONDS = 4 * 3600;

    // --- State ---
    let callData = [];
    let agentTrackMap = {};
    let agentProductivity = new Map();
    let totalTimeSeconds = END_OF_DAY_SECONDS - START_OF_DAY_SECONDS;
    let timeMin = START_OF_DAY_SECONDS;
    let timeMax = END_OF_DAY_SECONDS;
    let selectedAgents = [];

    // --- DOM Elements ---
    const timelineChart = document.getElementById('timeline-chart');
    const agentLabelContainer = document.getElementById('agent-label-container');
    const timelineScrollContainer = document.getElementById('timeline-scroll-container');
    const tooltip = document.getElementById('call-tooltip');
    const zoomSlider = document.getElementById('zoom-slider');
    const filterFeedback = document.getElementById('filter-feedback');
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('fileInput');
    const dropText = document.querySelector('#drop-area p.text-lg');

    // --- Utility Functions ---

    // Convert 'Call Length' to seconds (handles Date, Excel fractions, strings)
    const callLengthToSeconds = (val) => {
        if (val == null) return 0;

        // If already a Date (e.g., 00:02:35)
        if (val instanceof Date) {
            return val.getHours() * 3600 + val.getMinutes() * 60 + val.getSeconds();
        }

        // Numeric: likely Excel fractional day (e.g. 0.0038)
        if (typeof val === 'number') {
            if (val > 0 && val < 1) {
                return Math.round(val * 24 * 3600);
            }
            // If RingCentral ever exports as raw seconds, this still works.
            return Math.round(val);
        }

        // String: "HH:MM:SS" or "MM:SS"
        if (typeof val === 'string') {
            const parts = val.split(':').map(p => parseInt(p, 10));
            if (parts.length === 3) {
                const [h, m, s] = parts;
                if (!isNaN(h) && !isNaN(m) && !isNaN(s)) {
                    return h * 3600 + m * 60 + s;
                }
            } else if (parts.length === 2) {
                const [m, s] = parts;
                if (!isNaN(m) && !isNaN(s)) {
                    return m * 60 + s;
                }
            }
        }

        return 0;
    };

    /** Extracts clean agent name from RingCentral "From Name"/"To Name" formats. */
    const extractAgentName = (fullName) => {
        if (!fullName || typeof fullName !== 'string') return null;

        let cleaned = fullName;

        // Remove " - external party" or similar suffix
        if (cleaned.includes(' - ')) {
            cleaned = cleaned.split(' - ')[0];
        }

        // Remove phone/extension in parentheses
        if (cleaned.includes('(')) {
            cleaned = cleaned.split('(')[0];
        }

        cleaned = cleaned.trim();
        if (!cleaned) return null;

        const up = cleaned.toUpperCase();

        // Full-name / robust match
        for (const [upperTarget, originalName] of AGENT_MAP.entries()) {
            if (
                up === upperTarget ||
                up.startsWith(upperTarget) ||
                upperTarget.includes(up) ||
                up.includes(upperTarget)
            ) {
                return originalName;
            }
        }

        // Direct-line pattern: "<FirstName> Direct ..."
        const directIdx = up.indexOf(' DIRECT');
        if (directIdx > 0) {
            const before = up.slice(0, directIdx).trim();
            const maybeFirst = before.split(/\s+/).pop() || "";

            if (DIRECT_ALIAS_MAP[maybeFirst]) {
                return DIRECT_ALIAS_MAP[maybeFirst];
            }

            for (const [upperTarget, originalName] of AGENT_MAP.entries()) {
                const first = upperTarget.split(' ')[0];
                if (first === maybeFirst) {
                    return originalName;
                }
            }
        }

        // Last-name-only fallback
        for (const [upperTarget, originalName] of AGENT_MAP.entries()) {
            const last = upperTarget.split(' ').slice(-1)[0];
            if (last && up.includes(last)) {
                return originalName;
            }
        }

        return null;
    };

    /** Converts Date object to seconds from midnight. */
    const timeToSeconds = (date) => {
        return date.getHours() * 3600 + date.getMinutes() * 60 + date.getSeconds();
    };

    /** Formats seconds from midnight into HH:MM AM/PM string. */
    const formatTime = (seconds) => {
        const date = new Date(0, 0, 0, 0, 0, seconds);
        return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
    };

    /** Formats duration (in seconds) to Hh Mm Ss. */
    const formatDurationHms = (d) => {
        d = Math.round(Number(d));
        const h = Math.floor(d / 3600);
        const m = Math.floor((d % 3600) / 60);
        const s = d % 60;
        const hDisplay = h > 0 ? `${h}h ` : "";
        const mDisplay = m > 0 ? `${m}m ` : "";
        const sDisplay = s > 0 || (h === 0 && m === 0) ? `${s}s` : "";
        return (hDisplay + mDisplay + sDisplay).trim() || '0s';
    };

    /** Formats duration (in seconds) to Mm Ss for tooltips. */
    const formatDurationMs = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}m ${s}s`;
    };

    // --- Core Parsing for XLSX Rows ---

    const parseRows = (rows) => {
        callData = [];
        agentProductivity = new Map();
        let minTimeRaw = Infinity;

        rows.forEach((row) => {
            const fromName = row["From Name"];
            const toName = row["To Name"];
            const result = row["Result"];
            const direction = row["Call Direction"];
            const startTimeRaw = row["Call Start Time"];
            const callLengthVal = row["Call Length"];

            let agentName = extractAgentName(fromName);
            if (!agentName) {
                agentName = extractAgentName(toName);
            }
            if (!agentName) return;

            const callLength = callLengthToSeconds(callLengthVal);
            if (!callLength || callLength === 0) return;

            // Determine if call is valid + type
            let isValidCall = false;
            let callType = 'Attempted';

            if (VALID_RESULTS_CONNECTED.includes(result)) {
                isValidCall = true;
                callType = direction === 'Outbound' ? 'ConnectedOutbound' : 'ConnectedInbound';
            } else if (VALID_RESULTS_TRANSFERRED.includes(result)) {
                isValidCall = true;
                callType = 'Transferred';
            } else if (direction === 'Outbound' && callLength >= 5) {
                isValidCall = true;
                callType = 'OutboundAttempt';
            }

            if (!isValidCall) return;

            // Parse start time
            let startTime;
            if (startTimeRaw instanceof Date) {
                startTime = startTimeRaw;
            } else {
                startTime = new Date(startTimeRaw);
            }
            if (isNaN(startTime.getTime())) return;

            const startSeconds = timeToSeconds(startTime);
            const endSeconds = startSeconds + callLength;

            minTimeRaw = Math.min(minTimeRaw, startSeconds);

            const call = {
                agentName,
                startTime,
                startSeconds,
                endSeconds,
                callLength, // in seconds
                direction,
                result,
                callType
            };
            callData.push(call);

            const productiveTime = callLength; // use full call length in seconds

            if (!agentProductivity.has(agentName)) {
                agentProductivity.set(agentName, {
                    inboundTime: 0,
                    outboundTime: 0,
                    totalCalls: 0,
                    calls: []
                });
            }

            const stats = agentProductivity.get(agentName);
            stats.totalCalls += 1;

            if (callType === 'ConnectedInbound' || callType === 'Transferred') {
                stats.inboundTime += productiveTime;
            } else {
                stats.outboundTime += productiveTime;
            }
            stats.calls.push(call);
        });

        // Sort calls
        callData.sort((a, b) => a.startSeconds - b.startSeconds);
        agentProductivity.forEach(stats => {
            stats.calls.sort((a, b) => a.startSeconds - b.startSeconds);
        });

        const firstCallTime = minTimeRaw !== Infinity ? minTimeRaw : START_OF_DAY_SECONDS;

        // Map agents to track index and populate filter
        const sortedAgentNames = Array.from(agentProductivity.keys()).sort();
        agentTrackMap = {};
        sortedAgentNames.forEach((name, index) => {
            agentTrackMap[name] = index;
        });

        selectedAgents = sortedAgentNames;
        populateAgentFilter(sortedAgentNames);

        // Update date range summary
        let dateSummary = "No valid call data found.";
        if (callData.length > 0) {
            const dates = Array.from(
                new Set(callData.map(c => c.startTime.toLocaleDateString()))
            ).join(' & ');
            dateSummary = `Visualization spans activity on: ${dates}. Time axis is standardized to 8:30 AM - 5:30 PM.`;
            document.getElementById('date-range-summary').textContent = dateSummary;

            setTimeout(() => {
                const width = timelineChart.offsetWidth;
                const pixelsPerSecond = width / totalTimeSeconds;
                const scrollPosition = (firstCallTime - START_OF_DAY_SECONDS) * pixelsPerSecond;
                timelineScrollContainer.scrollLeft = Math.max(0, scrollPosition - 50);
            }, 50);
        } else {
            document.getElementById('date-range-summary').textContent = dateSummary;
        }

        return sortedAgentNames;
    };

    // --- Daily Stats ---

    const calculateDailyStats = () => {
        const stats = [];
        const agentNames = Array.from(agentProductivity.keys()).filter(name => selectedAgents.includes(name));

        agentNames.forEach(agentName => {
            const p = agentProductivity.get(agentName);
            const totalProductiveTime = p.inboundTime + p.outboundTime;

            const timeOffPhone = Math.max(0, NET_WORKDAY_SECONDS - totalProductiveTime);

            stats.push({
                agentName,
                totalCalls: p.totalCalls,
                inboundTime: p.inboundTime,
                outboundTime: p.outboundTime,
                totalProductiveTime,
                timeOffPhone
            });
        });

        return stats.sort((a, b) => a.agentName.localeCompare(b.agentName));
    };

    const renderDailyStats = () => {
        const stats = calculateDailyStats();
        const tbody = document.getElementById('stats-table-body');
        const summaryArea = document.getElementById('stats-summary-area');

        if (stats.length === 0) {
            summaryArea.style.display = 'none';
            return;
        }

        tbody.innerHTML = '';
        summaryArea.style.display = 'block';

        stats.forEach((stat, i) => {
            const row = document.createElement('tr');
            row.className = `hover:bg-gray-100 ${i % 2 === 1 ? 'bg-gray-50' : 'bg-white'}`;

            const offPhoneClass = stat.timeOffPhone > IDLE_TIME_HIGHLIGHT_SECONDS
                ? 'text-red-700 font-semibold'
                : 'text-gray-700';

            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${stat.agentName}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700">${stat.totalCalls}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-emerald-600">${formatDurationHms(stat.inboundTime)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-indigo-600">${formatDurationHms(stat.outboundTime)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-700">${formatDurationHms(stat.totalProductiveTime)}</td>
                <td class="px-6 py-4 whitespace-nowrap text-sm ${offPhoneClass}">${formatDurationHms(stat.timeOffPhone)}</td>
            `;
            tbody.appendChild(row);
        });
    };

    // --- Visualization Rendering ---

    const populateAgentFilter = (agentNames) => {
        const container = document.getElementById('agent-list-panel');
        container.innerHTML = '';

        agentNames.forEach(agentName => {
            const item = document.createElement('label');
            item.className = 'agent-checkbox-item px-2';
            item.htmlFor = `timeline-agent-${agentName.replace(/\s/g, '-')}`;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `timeline-agent-${agentName.replace(/\s/g, '-')}`;
            checkbox.value = agentName;
            checkbox.checked = true;
            checkbox.className = 'mr-2 rounded text-emerald-600 focus:ring-emerald-500';

            item.appendChild(checkbox);
            item.appendChild(document.createTextNode(agentName));
            container.appendChild(item);
        });

        filterFeedback.textContent = `${agentNames.length} Agents Selected`;
    };

    const renderTimeline = (zoomLevel) => {
        const width = 1500 * (zoomLevel / 100);
        timelineChart.style.width = `${width}px`;

        timelineChart.innerHTML = '';
        agentLabelContainer.innerHTML = '';

        const tracksToShow = Object.keys(agentTrackMap).filter(name => selectedAgents.includes(name));

        const visibleAgentTrackMap = {};
        tracksToShow.forEach((name, index) => visibleAgentTrackMap[name] = index);

        timelineChart.style.height = `${(tracksToShow.length + 1) * 35}px`;

        // 1. Time Axis
        const timeAxis = document.createElement('div');
        timeAxis.className = 'absolute top-0 left-0 w-full h-8 flex border-b border-gray-300';

        for (let s = START_OF_DAY_SECONDS; s <= END_OF_DAY_SECONDS; s += 1800) {
            const position = ((s - timeMin) / totalTimeSeconds) * 100;
            if (position > 100) break;

            const marker = document.createElement('div');
            marker.className = 'absolute h-full text-xs text-gray-500 pt-1 text-center font-medium';
            marker.style.left = `${position}%`;
            marker.style.transform = 'translateX(-50%)';
            marker.style.borderLeft = '1px dashed #ccc';
            marker.style.width = '1px';
            marker.textContent = formatTime(s);

            timeAxis.appendChild(marker);
        }
        timelineChart.appendChild(timeAxis);

        // 2. Labels & tracks
        tracksToShow.forEach((agentName, index) => {
            const trackTop = (index + 1) * 35;

            const label = document.createElement('div');
            label.className = 'agent-label-row px-3 text-sm font-medium text-gray-800 truncate';
            label.textContent = agentName;
            agentLabelContainer.appendChild(label);

            const track = document.createElement('div');
            track.className = 'agent-track w-full';
            track.style.top = `${trackTop}px`;
            track.style.position = 'absolute';
            timelineChart.appendChild(track);
        });

        // 3. Downtime + call bars
        tracksToShow.forEach(agentName => {
            const trackIndex = visibleAgentTrackMap[agentName];
            const trackTop = (trackIndex + 1) * 35;
            const calls = agentProductivity.get(agentName)?.calls || [];

            let lastEndTime = START_OF_DAY_SECONDS;

            calls.forEach(call => {
                // Downtime
                const gapStart = Math.max(lastEndTime, START_OF_DAY_SECONDS);
                const gapEnd = Math.min(call.startSeconds, END_OF_DAY_SECONDS);

                if (gapEnd > gapStart) {
                    const gapDuration = gapEnd - gapStart;
                    const gapPosition = ((gapStart - timeMin) / totalTimeSeconds) * width;
                    const gapWidth = (gapDuration / totalTimeSeconds) * width;

                    const downtimeBar = document.createElement('div');
                    downtimeBar.className = 'downtime-bar';
                    downtimeBar.style.left = `${gapPosition}px`;
                    downtimeBar.style.width = `${gapWidth}px`;
                    downtimeBar.style.top = `${trackTop + 16}px`;
                    timelineChart.appendChild(downtimeBar);
                }

                lastEndTime = call.endSeconds;

                // Call bar
                const callStart = Math.max(call.startSeconds, START_OF_DAY_SECONDS);
                const callEnd = Math.min(call.endSeconds, END_OF_DAY_SECONDS);
                const callDuration = callEnd - callStart;

                if (callDuration > 0) {
                    const startPosition = ((callStart - timeMin) / totalTimeSeconds) * width;
                    const durationWidth = (callDuration / totalTimeSeconds) * width;

                    const bar = document.createElement('div');

                    let bgColor = 'bg-gray-400';
                    if (call.callType === 'ConnectedInbound') {
                        bgColor = 'bg-green-500';
                    } else if (call.callType === 'ConnectedOutbound') {
                        bgColor = 'bg-blue-500';
                    } else if (call.callType === 'Transferred') {
                        bgColor = 'bg-yellow-500';
                    } else if (call.callType === 'OutboundAttempt') {
                        bgColor = 'bg-blue-300';
                    }

                    bar.className = `call-bar ${bgColor}`;
                    bar.style.left = `${startPosition}px`;
                    bar.style.width = `${Math.max(3, durationWidth)}px`;
                    bar.style.top = `${trackTop + 5}px`;

                    bar.dataset.agent = call.agentName;
                    bar.dataset.direction = call.direction;
                    bar.dataset.start = call.startTime.toLocaleTimeString('en-US');
                    bar.dataset.duration = formatDurationMs(call.callLength);
                    bar.dataset.result = call.result;

                    bar.addEventListener('mousemove', showTooltip);
                    bar.addEventListener('mouseleave', hideTooltip);

                    timelineChart.appendChild(bar);
                }
            });

            // Final downtime
            const finalGapStart = Math.max(lastEndTime, START_OF_DAY_SECONDS);
            const finalGapEnd = END_OF_DAY_SECONDS;

            if (finalGapEnd > finalGapStart) {
                const gapDuration = finalGapEnd - finalGapStart;
                const gapPosition = ((finalGapStart - timeMin) / totalTimeSeconds) * width;
                const gapWidth = (gapDuration / totalTimeSeconds) * width;

                const downtimeBar = document.createElement('div');
                downtimeBar.className = 'downtime-bar';
                downtimeBar.style.left = `${gapPosition}px`;
                downtimeBar.style.width = `${gapWidth}px`;
                downtimeBar.style.top = `${trackTop + 16}px`;
                timelineChart.appendChild(downtimeBar);
            }
        });

        filterFeedback.textContent = `${selectedAgents.length} Agents Selected`;
        renderDailyStats();
    };

    const showTooltip = (e) => {
        const bar = e.currentTarget;

        let directionLabel = bar.dataset.direction;
        if (VALID_RESULTS_TRANSFERRED.includes(bar.dataset.result)) {
            directionLabel = 'Transfer';
        } else if (!VALID_RESULTS_CONNECTED.includes(bar.dataset.result)) {
            directionLabel = 'Outbound Attempt';
        }

        tooltip.innerHTML = `
            <div class="text-sm font-bold text-white mb-1">${bar.dataset.agent}</div>
            <div class="text-xs text-gray-300">
                <p><strong>Type:</strong> ${directionLabel}</p>
                <p><strong>Result:</strong> ${bar.dataset.result}</p>
                <p><strong>Start Time:</strong> ${bar.dataset.start}</p>
                <p><strong>Duration:</strong> ${bar.dataset.duration}</p>
            </div>
        `;

        const rect = bar.getBoundingClientRect();
        const scrollRect = timelineScrollContainer.getBoundingClientRect();
        const scrollLeft = timelineScrollContainer.scrollLeft;

        const x = rect.left - scrollRect.left + rect.width / 2 + scrollLeft;
        const y = rect.top - scrollRect.top;

        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
        tooltip.classList.add('show-tooltip');
    };

    const hideTooltip = () => {
        tooltip.classList.remove('show-tooltip');
    };

    // --- Event Handlers ---

    const handleFilterChange = () => {
        const checkboxes = document.querySelectorAll('#agent-list-panel input[type="checkbox"]');
        selectedAgents = [];
        checkboxes.forEach(cb => {
            if (cb.checked) selectedAgents.push(cb.value);
        });
        renderTimeline(zoomSlider.value);
    };

    const handleClearSelection = () => {
        const checkboxes = document.querySelectorAll('#agent-list-panel input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = false);
        handleFilterChange();
    };

    const handleZoomChange = (e) => {
        renderTimeline(e.target.value);
    };

    const handleWorkbook = (workbook) => {
        const sheet = workbook.Sheets["Calls"] || workbook.Sheets[workbook.SheetNames[0]];
        if (!sheet) {
            dropText.textContent = "No 'Calls' sheet found in this workbook.";
            return;
        }
        const rows = XLSX.utils.sheet_to_json(sheet, { defval: "" });
        const agentNames = parseRows(rows);

        if (agentNames.length > 0) {
            renderTimeline(zoomSlider.value);
            document.getElementById('visualization-area').classList.remove('hidden');
        } else {
            document.getElementById('visualization-area').classList.add('hidden');
            dropText.textContent = "Data loaded, but no matching connected calls found for tracked agents.";
        }
    };

    const handleFileUpload = (file) => {
        const name = file.name.toLowerCase();
        if (!(name.endsWith('.xlsx') || name.endsWith('.xls'))) {
            dropText.textContent = "Please drop a RingCentral XLSX Calls file (.xlsx).";
            return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            handleWorkbook(workbook);
            dropText.textContent = `Loaded ${file.name}`;
        };
        reader.readAsArrayBuffer(file);
        dropText.textContent = `Processing ${file.name}...`;
    };

    // --- Initialization ---

    const initApp = () => {
        // File picker
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileUpload(file);
        });

        // Drag and Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });

        dropArea.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            if (dt.files && dt.files.length) handleFileUpload(dt.files[0]);
        }, false);

        dropArea.addEventListener('click', () => fileInput.click());

        // Controls
        zoomSlider.addEventListener('input', handleZoomChange);
        document.getElementById('applyFilter').addEventListener('click', handleFilterChange);
        document.getElementById('clearSelection').addEventListener('click', handleClearSelection);

        // Initial empty render (nothing visible until data load, but keeps layout consistent)
        renderTimeline(zoomSlider.value);
    };

    window.onload = initApp;
</script>
</body>
</html>
11.11
